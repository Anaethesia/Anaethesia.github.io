[{"content":"Chapter 2 编译原理 编译的核心过程 ​\t词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和 机器代码生成。\n词法和语法分析 ​\t词法： 将字符序列转换为标记序列的过程。\n​\tGo语言中Scanner结构体（syntax.scanner)持有当前扫描的数据源文件、启用的模式和当前被扫描到的 Token.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  type scanner struct { source mode uint nlsemi bool // current token, valid after calling next() \tline, col uint blank bool // line is blank up to col \ttok token lit string // valid if tok is _Name, _Literal, or _Semi (\u0026#34;semicolon\u0026#34;, \u0026#34;newline\u0026#34;, or \u0026#34;EOF\u0026#34;); may be malformed if bad is true \tbad bool // valid if tok is _Literal, true if a syntax error occurred, lit may be malformed \tkind LitKind // valid if tok is _Literal \top Operator // valid if tok is _Operator, _AssignOp, or _IncOp \tprec int // valid if tok is _Operator, _AssignOp, or _IncOp }   ​\t词法分析主要是由scanner中的next方法，将字面量、操作符、分隔符和关键字等区别开，swich case 判断。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func (s *scanner) next() { ... s.stop() startLine, startCol := s.pos() for s.ch == \u0026#39; \u0026#39; || s.ch == \u0026#39;\\t\u0026#39; || s.ch == \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; !nlsemi || s.ch == \u0026#39;\\r\u0026#39; { s.nextch() } s.line, s.col = s.pos() s.blank = s.line \u0026gt; startLine || startCol == colbase s.start() if isLetter(s.ch) || s.ch \u0026gt;= utf8.RuneSelf \u0026amp;\u0026amp; s.atIdentChar(true) { s.nextch() s.ident() return } switch s.ch { case -1: s.tok = _EOF case \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;: s.number(false) ... } }   ​\t语法：词法输出的token序列是语法分析器的输入，进而确定语法结构\n​\tGo 语言的解析器使用了 LALR(1) 的文法来解析词法分析过程中输出的 Token 序列，最右推导加向前查看构成了 Go 语言解析器的最基本原理，也是大多数编程语言的选择。\n​\tGo语言文法的实现是parser结构体的fileOrNil方法。\n​\t类型检查 ​\t强弱类型\n 强类型的编程语言在编译期间会有更严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误； （Go， JAVA） 弱类型的编程语言在出现类型错误时可能会在运行时进行隐式的类型转换，在类型转换时可能会造成运行错误。  ​\t静态类型和动态类型\n​\t静态类型：基于对源代码的分析来确定运行程序类型安全的过程。 在重构时能够帮助我们节省大量时间并避免遗漏。\n​\t动态类型：在运行时确定程序类型安全的过程，它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性。\n​\tWhat about Go？\n​\tGo 语言的编译器不仅使用静态类型检查来保证程序运行的类型安全，还会在编程期间引入类型信息，让工程师能够使用反射（reflect）来判断参数和变量的类型。当我们想要将 interface{} 转换成具体类型时会进行动态类型检查，如果无法发生转换就会发生程序崩溃。\n​\tGo编译器类型检查的主要逻辑在 cmd/compile/internal/gc.typecheck 和cmd/compile/internal/gc.typecheck1中。\n中间代码生成 ​\t​\t中间代码的生成过程是从 AST 抽象语法树到 SSA 中间代码的转换过程。在这期间会对语法树中的关键字再进行改写，改写后的语法树会经过多轮处理转变成最后的 SSA 中间代码，相关代码中包括了大量 switch 语句、复杂的函数和调用栈，阅读和分析起来也非常困难。\n图 SSA 中间代码生成过程\n机器码生成 ​\t指令集架构\n​\t复杂指令集（CISC): 指令数目多并且复杂，每条指令的字节长度并不相等。\u0026ndash; x86\n​\t精简指令集（RISC):指令的数目和寻址方式做了精简，大大减少指令数量的同时更容易实现，指令集中的每一个指令都使用标准的字节长度、执行时间相比复杂指令集会少很多，处理器在处理指令时也可以流水执行，提高了对并行的支持。\u0026ndash; arm\nChapter 3 数据结构 ","permalink":"https://Anaethesia.github.io/posts/tech/design-implement-go/","summary":"Chapter 2 编译原理 编译的核心过程 ​ 词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和 机器代码生成。 词法和语法分析 ​ 词法： 将字符序列转换为标记序列的过程","title":"Learning notes of Design and implement of Go"},{"content":"read2 test\n","permalink":"https://Anaethesia.github.io/posts/read/read2/","summary":"read2 test","title":"Read2"},{"content":"This is test for read.\n","permalink":"https://Anaethesia.github.io/posts/read/read/","summary":"This is test for read.","title":"Read"}]